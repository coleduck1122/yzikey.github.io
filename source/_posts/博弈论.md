---
title: 博弈论
tags: 
- 博弈论
categories:
- ACM
---

### NIM博弈

##### 题型1 (模板题)

题意: 
共有n堆石子，每堆有ai个石子，每次一个人可以轮流选择任意一堆，取走任意多的石子（不能不取），取到最后一个石子的人获胜。判断是否先手必胜。

```
//记nim = a1^a2^a3^...^an, nim = 0时先手必败，反之必胜

void solve() {
    int n;  cin >> n;
    int sum = 0;
    for (int i = 1; i <= n; i ++ ) {
        cin >> a[i];
        sum ^= a[i];
    }    
    if (sum == 0) {
        cout << "No" << endl;
        return;
    }
    cout << "Yes" << endl;
}
```

##### 题型2 (模板题变形)

题意: 
共有n堆石子，每堆有ai个石子，每次一个人可以轮流选择任意一堆，取走任意多的石子（不能不取），取到最后一个石子的人获胜。接下来先手试图开局先取第k堆石子，判断是否先手必胜。

```
//记nim = a1^a2^a3^...^an, 且nim的最高位1在第i位
//当先手nim = 0时，或者第k堆石子第i位bit不是1(即不能将必胜态转为必败态)时，先手必败

void solve() {
    int n, k;  cin >> n >> k;
    int sum = 0;
    for (int i = 1; i <= n; i ++ ) {
        cin >> a[i];
        sum ^= a[i];
    }    
    int bit = 0;
    for (int i = 30; i >= 0; i -- ) {
        if ((sum >> i) & 1) {
            bit = i;
            break;
        }
    }
    if (!((a[k] >> bit) & 1) || sum == 0) {
        cout << "No" << endl;
        return;
    }
    cout << "Yes" << endl;
}
```

### 阶梯NIM博弈

在阶梯的每一层上有若干个石子，每次可以选择任意层的任意个石子将其移动到下一层，最后不能移动的人输。

```
//记nim = a1^a3^a5^...^a(2n-1), nim = 0时先手必败，反之必胜
//先手总能将奇数项异或和非0的状态转移到奇数项异或和为0，留给后手

void solve() {
    int n, num, sum = 0; cin >> n;
    for (int i = 1; i <= n; i ++ ) {
        cin >> num;
        if (i % 2) sum ^= num;
    }
    if (sum == 0) cout << "No" << endl;
    else cout << "Yes" << endl;
}
```

### 巴什博弈

题意: 
共有n堆石子，每堆有ai个石子，每次一个人可以轮流选择任意一堆，取走至少1颗，至多m颗石子，取到最后一个石子的人获胜。判断是否先手必胜。

```
//令bi = ai % (m + 1);
//记nim = b1^b2^b3^...^bn, nim = 0时先手必败，反之必胜

```

### SG函数

设x1, x2, ... , xn为ICG的状态, 则
SG(x1 + x2 + ... + xn) = SG(x1) ^ SG(x2) ^ ... ^ SG(xn)


```
//f[]:  可转移状态的方式集合，f[]要在getSG之前先预处理
//SG[]: 0 - n的SG函数值
//S[]:  一次操作后的后继状态的集合

const int N = 1e4 + 10;
const int M = 20;
int SG[N], S[N];
int f[M];

void getSG(int n) {
    memset(SG, 0, sizeof SG);
    for (int i = 1; i <= n; i ++ ) {
        memset(S, 0, sizeof S);
        for (int j = 0; f[j] <= i && j <= N; j ++ )
            S[SG[i - f[j]]] = 1;
        for (int j = 0; ; j ++ ) //计算mex
            if (!S[j]) {
                SG[i] = j;
                break;
            }
    }
}
```