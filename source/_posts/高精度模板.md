---
title: 高精度模板
tags:
- 高精度
categories:
- ACM
---

### 高精度加法O(n)

```
//只限两个非负整数相加

const int maxlen = 1e5 + 10;
string add(string a, string b) 
{   
    int A[maxlen] = {0}, B[maxlen] = {0};
    int lenA = a.size(), lenB = b.size();
    for (int i = 0; i < lenA; i ++ ) A[lenA - i - 1] = a[i] - '0';
    for (int i = 0; i < lenB; i ++ ) B[lenB - i - 1] = b[i] - '0';
    int Max = lenA > lenB ? lenA : lenB;
    for (int i = 0; i < Max; i ++ ) {
        A[i] += B[i];
        A[i + 1] += A[i] / 10;
        A[i] %= 10;
    }
    string res = "";
    if (A[Max]) Max ++ ;
    for (int i = Max - 1; i >= 0; i -- ) res += A[i] + '0';
    return res;
}
```


### 高精度减法O(n)

```
//只限大的非负整数减小的非负整数

const int maxlen = 1e5 + 10;
string sub(string a, string b) 
{   
    int A[maxlen] = {0}, B[maxlen] = {0};
    int lenA = a.size(), lenB = b.size();
    for (int i = 0; i < lenA; i ++ ) A[lenA - i - 1] = a[i] - '0';
    for (int i = 0; i < lenB; i ++ ) B[lenB - i - 1] = b[i] - '0';
    int Max = lenA > lenB ? lenA : lenB;
    for (int i = 0; i < Max; i ++ ) {
        A[i] -= B[i];
        if (A[i] < 0) {
            A[i] += 10;
            A[i + 1] -- ;
        }
    }
    string res = "";
    while (A[Max] == 0 && Max > 0) Max -- ;
    for (int i = Max; i >= 0; i -- ) res += A[i] + '0';
    return res;
}
```

### 高精乘单精O(n)

```
//高精度a乘单精度b

const int maxlen = 1e5 + 10;
string mul(string a, int b) {
    int A[maxlen] = {0};
    int lenA = a.size(), w = 0; //w保存进位信息
    for (int i = lenA - 1; i >= 0; i -- ) 
        A[lenA - i - 1] = a[i] - '0';
    for (int i = 0; i < lenA; i ++ ) {
        A[i] = A[i] * b + w;
        w = A[i] / 10;
        A[i] %= 10;
    }
    while (w) {
        A[lenA] = w % 10;
        w /= 10;
        lenA ++ ;
    }
    string res = "";
    for (int i = lenA - 1; i >= 0; i -- ) 
        res += A[i] + '0';
    return res;
}
```

### 高精乘高精O(n*n)

```
//高精a乘高精b，均为非负整数

const int maxlen = 1e5 + 10;
string mul(string a, string b) {
    int A[maxlen] = {0}, B[maxlen] = {0}, C[2 * maxlen] = {0};
    int lenA = a.size(), lenB = b.size();
    for (int i = 0; i < lenA; i ++ ) A[lenA - i] = a[i] - '0';
    for (int i = 0; i < lenB; i ++ ) B[lenB - i] = b[i] - '0';
    for (int i = 1; i <= lenA; i ++ ) //先不考虑进位
        for (int j = 1; j <= lenB; j ++ )
            C[i + j - 1] += A[i] * B[j];
    for (int i = 1; i <= lenA + lenB; i ++ ) {
        C[i + 1] += C[i] / 10;
        C[i] %= 10;
    }
    string res = "";
    if (C[lenA + lenB]) res += C[lenA + lenB] + '0;
    for (int i = lenA + lenB - 1; i >= 1; i -- ) res += C[i] + '0';
    return res;
}
```

### 高精乘高精O(nlogn)



```
// AcWing 3123 高精度乘法
// 题意：给你两个数A和B，求A * B
// 数据范围：1 <= A, B的长度 <= 1e5
// 这个用到了FFT的知识，想了解详情请戳上面的链接

#include <bits/stdc++.h>

using namespace std;

const int N = 3e5 + 10;
const double PI = acos(-1);

typedef struct complex {
    double x, y;

    complex operator+ (complex& t) const {
        return {x + t.x, y + t.y};
    }
    complex operator- (complex& t) const {
        return {x - t.x, y - t.y};
    }
    complex operator* (complex& t) const {
        return {x * t.x - y * t.y, x * t.y + y * t.x};
    }
} Complex;

int res[N];
int rev[N], bit, tot;
char s1[N], s2[N];
Complex a[N], b[N];

void fft(Complex a[], int inv) {
    for (int i = 0; i < tot; i ++ )
        if (i < rev[i])
            swap(a[i], a[rev[i]]);
    
    for (int mid = 1; mid < tot; mid <<= 1) {
        Complex w1 = {cos(PI / mid), inv * sin(PI / mid)};
        for (int i = 0; i < tot; i += mid * 2) {
            Complex wk = {1, 0};
            for (int j = 0; j < mid; j ++ , wk = wk * w1) {
                auto x = a[i + j], y = wk * a[i + j + mid];
                a[i + j] = x + y, a[i + j + mid] = x - y;
            }
        }
    }
}

int main() {

    cin >> s1 >> s2;
    int n = strlen(s1) - 1, m = strlen(s2) - 1;
    for (int i = 0; i <= n; i ++ ) a[i].x = (s1[n - i] - '0');
    for (int i = 0; i <= m; i ++ ) b[i].x = (s2[m - i] - '0');

    while ((1 << bit) < n + m + 1) bit ++ ;
    tot = (1 << bit);
    for (int i = 0; i < tot; i ++ )
        rev[i] = (rev[i >> 1] >> 1) | ((i & 1) << (bit - 1));
    
    fft(a, 1), fft(b, 1);
    for (int i = 0; i < tot; i ++ ) a[i] = a[i] * b[i];
    fft(a, -1);

    int k = 0;
    for (int i = 0, t = 0; i < tot || t; i ++ ) {
        t += (int)(a[i].x / tot + 0.5);
        res[k ++ ] = t % 10;
        t /= 10;
    }

    while (k > 1 && !res[k - 1]) k -- ;
    for (int i = k - 1; i >= 0; i -- ) cout << res[i];

    return 0;
}
```

### 高精除单精O(n)

```
//高精度a除以单精度b，整除

string div(string a, int b) {
    if (a == "0") return a;

    int d = 0;
    string r = "";
    for (int i = 0; i < a.size(); i ++ ) {
        r += (d * 10 + a[i] - '0') / b + '0';  //求商
        d = (d * 10 + a[i] - '0') % b;  //求余
    }
    int pos = r.size() - 1;
    for (int i = 0; i < r.size(); i ++ )
        if (r[i] != '0') {
            pos = i;
            break;
        }
    return r.substr(pos);
}
```


### 高精除高精O(n)

```
//还未测试

int sub(int *a,int *b,int La,int Lb)
{
    if(La<Lb) return -1;//如果a小于b，则返回-1
    if(La==Lb)
    {
        for(int i=La-1;i>=0;i--)
            if(a[i]>b[i]) break;
            else if(a[i]<b[i]) return -1;//如果a小于b，则返回-1

    }
    for(int i=0;i<La;i++)//高精度减法
    {
        a[i]-=b[i];
        if(a[i]<0) a[i]+=10,a[i+1]--;
    }
    for(int i=La-1;i>=0;i--)
        if(a[i]) return i+1;//返回差的位数
    return 0;//返回差的位数

}

string div(string n1,string n2,int nn)
{
    const int L=1e5;
    string s,v;//s存商,v存余数
    int a[L],b[L],r[L],La=n1.size(),Lb=n2.size(),i,tp=La;
    //a，b是整形数组表示被除数，除数，tp保存被除数的长度
    fill(a,a+L,0);fill(b,b+L,0);fill(r,r+L,0);//数组元素都置为0
    for(i=La-1;i>=0;i--) a[La-1-i]=n1[i]-'0';
    for(i=Lb-1;i>=0;i--) b[Lb-1-i]=n2[i]-'0';
    if(La<Lb || (La==Lb && n1<n2)) {
        //cout<<0<<endl;
    return n1;}//如果a<b,则商为0，余数为被除数
    int t=La-Lb;//除被数和除数的位数之差
    for(int i=La-1;i>=0;i--)//将除数扩大10^t倍
    if(i>=t) b[i]=b[i-t];
    else b[i]=0;
    Lb=La;
    for(int j=0;j<=t;j++)
    {
        int temp;
        while((temp=sub(a,b+j,La,Lb-j))>=0)//如果被除数比除数大继续减
        {
            La=temp;
            r[t-j]++;
        }
    }
    for(i=0;i<L-10;i++) r[i+1]+=r[i]/10,r[i]%=10;//统一处理进位
    while(!r[i]) i--;//将整形数组表示的商转化成字符串表示的
    while(i>=0) s+=r[i--]+'0';
    //cout<<s<<endl;
    i=tp;
    while(!a[i]) i--;//将整形数组表示的余数转化成字符串表示的</span>
    while(i>=0) v+=a[i--]+'0';
    if(v.empty()) v="0";
    //cout<<v<<endl;
    if(nn==1) return s;//返回商
    if(nn==2) return v;//返回余数
}
```